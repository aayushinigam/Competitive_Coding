#include <bits/stdc++.h>

using namespace std;

/* Template file (modified) for Online Algorithmic Competitions */
/* Macros */
	/* Loops */
	#define fl(i,a,b) for(int i(a);i<(b);i++)
	#define MOD 1000000007

int main(){

	#ifndef ONLINE_JUDGE
	freopen("/Users/sahilbansal/Desktop/input.txt","r",stdin);
	freopen("/Users/sahilbansal/Desktop/output.txt","w",stdout);
	#endif

	int x, y, n;

	cin >> x >> y;
	cin >> n;

	/*
		Base cases:
		f(1) = x
		f(2) = y
		Recursive case:
		f(i + 1) = f(i) - f(i - 1)
		i.e. f(n) = f(n - 1) - f(n - 2)

		We need to calculate f(n) % MOD
		f(n) % MOD = (f(n - 1) % MOD - f(n - 2) % MOD + MOD) % MOD
	*/

	/*
		A brute force O(N) solution won't work here because of the limits of N.
		So, either we solve the recurrence to get an explicit formula, which
		is a tedious task, we can easily identify a pattern here.
		f(1) = x
		f(2) = y
		f(3) = y - x
		f(4) = -x
		f(5) = -y
		f(6) = -y + x
		f(7) = x
		Now, it starts repeating, 
		Thus, the periodicity of the sequence generated by this recurrence is 6.
	*/


	/* just maintain 2 previous values and the current value */
	/* shift initially by MOD to adjust negative values */
	int prev = y + MOD, prev_prev = x + MOD, current;
	int effective_term_number = n % 6;
	
	/* 
		if(n % 6 == 0) then we want 6th term.
	*/
	if(effective_term_number == 0){
		effective_term_number = 6;
	}

	/* 
	  Base cases: 1st and 2nd terms 
	*/
	if(effective_term_number == 1){
		cout << (x + MOD) % MOD;
		return 0;
	}
	if(effective_term_number == 2){
		cout << (y + MOD) % MOD;
		return 0;
	}

	fl(i, 3, effective_term_number + 1){
		current = (prev % MOD - prev_prev % MOD + MOD) % MOD;
		prev_prev = prev;
		prev = current; 
	}

	cout << current;
	return 0;
}